## Technologies Used

* .NET 8.0
* ASP.NET Core Web API
* Entity Framework Core (with SQLite by default, configurable for SQL Server)
* Serilog for Logging
* Swashbuckle.AspNetCore for Swagger/OpenAPI
* Microsoft.AspNetCore.RateLimiting for API rate limiting
* Microsoft.AspNetCore.ResponseCompression for HTTP response compression
* CsvHelper for CSV file parsing
* AutoMapper for object mapping
* Azure.Storage.Blobs (optional, for Azure Blob file source)

## Getting Started

### Prerequisites

* .NET 8.0 SDK installed
* Visual Studio 2022 (recommended) or VS Code with C# extensions.
* Basic understanding of SQL migrations.

### Setup Steps

1.  **Clone the Repository (or create manually):**
    If you're following the manual creation, ensure you have created the solution and projects as specified in the initial setup instructions.

2.  **Add Project References:**
    Ensure all projects have the correct references as outlined in the "Setup Instructions" section above.

3.  **Install NuGet Packages:**
    Ensure all necessary NuGet packages are installed for each project as listed in the "Setup Instructions". **Remember to add `AutoMapper.Extensions.Microsoft.DependencyInjection` to `MunicipalityTax.Application` project.**

4.  **Database Migration:**
    * Open **Package Manager Console** in Visual Studio (`Tools > NuGet Package Manager > Package Manager Console`).
    * Select `MunicipalityTax.Infrastructure` as the **Default project** in the dropdown.
    * Run the following commands:
        ```powershell
        Add-Migration InitialCreate # Or a new name like AddAutoMapperMappers if you already ran InitialCreate
        Update-Database
        ```
        This will create the `municipality_taxes.db` SQLite file in your `MunicipalityTax.API` project's root directory (or equivalent for other DBs) and seed initial data.

5.  **Configure `appsettings.json` (Optional - for different DB/Cloud Storage):**
    * Open `MunicipalityTax.API/appsettings.json`.
    * To switch database, change `"DatabaseProvider"` to `"SqlServer"` and update `"SqlServerConnection"` string.
    * To enable Azure Blob import, uncomment the `AzureBlobStorage` connection string and `FileSourceProviders:AzureBlob:ContainerName` and populate with your Azure Storage details.

### Running the Application

1.  **Set Startup Project:**
    * In Solution Explorer, right-click the `MunicipalityTax.API` project and select "Set as Startup Project".

2.  **Run API:**
    * Press `F5` or `Ctrl+F5` (Start Without Debugging) in Visual Studio.
    * The API will launch, and Swagger UI will open in your default browser (typically at `https://localhost:7001/swagger`).

3.  **Explore API with Swagger UI:**
    * You can now interact with the API endpoints directly from the Swagger UI. Try:
        * `GET /api/Tax/{municipalityName}/{date}`
        * `POST /api/Municipality/taxrule`
        * `PUT /api/Municipality/taxrule/{ruleId}`
        * `POST /api/Municipality/import` (for file import)

4.  **Run Consumer Application:**
    * Right-click the `MunicipalityTax.Consumer` project and select "Set as Startup Project".
    * Run the consumer application (F5 or Ctrl+F5). This will execute a series of API calls and print the results to the console.
    * **Important:** The consumer expects a `sample_taxes.csv` file. A helper method in `MunicipalityTax.Consumer/Program.cs` will attempt to create this file in the consumer's executable directory if it doesn't exist. You can manually create it or modify the path in the `Program.cs`.

## API Endpoints

* **GET /api/Tax/{municipalityName}/{date}**
    * Calculates the tax for a given municipality on a specific date.
    * Example: `https://localhost:7001/api/Tax/Bangalore/2024-07-10`

* **POST /api/Municipality/taxrule**
    * Adds a new tax rule for a municipality.
    * Request Body (JSON): `AddTaxRuleCommand`

* **PUT /api/Municipality/taxrule/{ruleId}**
    * Updates an existing tax rule.
    * Request Body (JSON): `UpdateTaxRuleCommand`

* **POST /api/Municipality/import**
    * Imports tax rules from a file source.
    * Request Body (JSON): `ImportTaxesRequest`
        ```json
        {
          "identifier": "path/to/your/file.csv", // e.g., "C:\\temp\\taxes.csv" or "my_blob.csv"
          "fileSourceProviderName": "LocalFile" // or "AzureBlob"
        }
        ```

## Best Practices Implemented

* **Clean Architecture:** Clear separation of concerns, high cohesion, low coupling.
* **Dependency Injection:** Services and repositories are registered and injected.
* **Strategy Pattern:** For extensible tax calculation logic.
* **Repository Pattern:** Abstracts data access details.
* **Generic Configuration:** Database provider and logging setup are driven by configuration.
* **XML Documentation:** Provides rich API documentation in Swagger.
* **Rate Limiting:** Protects the API from excessive requests.
* **Response Compression:** Optimizes network traffic for faster client responses.
* **Global Error Handling:** Centralized exception handling for consistent API responses.
* **Serilog:** Powerful and flexible logging framework.
* **AutoMapper:** Streamlines object mapping, reducing boilerplate and improving maintainability.



Add-Migration InitialCreate -Project MunicipalityTax.Infrastructure -StartupProject MunicipalityTax.API

Update-Database -Project MunicipalityTax.Infrastructure -StartupProject MunicipalityTax.API




private int GetTaxTypePrecedence(TaxType type)
        {
            return type switch
            {
                TaxType.Daily => 4,   // Highest precedence
                TaxType.Weekly => 3,  // Next highest
                TaxType.Monthly => 2, // Next
                TaxType.Yearly => 1,  // Lowest precedence (default)
                _ => 0 // Should not occur for defined TaxTypes
            };
        }

        public async Task<decimal?> GetTaxAsync(string municipalityName, DateTime date)
        {
            var allRules = await _municipalityTaxRepository.GetAllTaxRulesAsync();

            var applicableRules = allRules
                .Where(r => r.MunicipalityName.Equals(municipalityName, StringComparison.OrdinalIgnoreCase) &&
                            date >= r.StartDate && date <= r.EndDate)
                .ToList();

            if (!applicableRules.Any())
            {
                return 0.0m; // No rule found for the given municipality and date
            }

            // 1. Order rules by their general TaxType precedence (Daily > Weekly > Monthly > Yearly)
            // 2. Then, within the same TaxType precedence, order by specific day matches (e.g., a Monthly rule for DayOfMonth=1 is more specific than a Monthly rule for the whole month).
            var mostSpecificRule = applicableRules
                .OrderByDescending(r => GetTaxTypePrecedence(r.TaxType)) // Apply the custom precedence
                .ThenByDescending(r =>
                {
                    // Assign a score for exact day matches within their tax type
                    if (r.TaxType == TaxType.Daily && r.DayOfYear.HasValue && r.DayOfYear.Value == date.DayOfYear) return 1;
                    if (r.TaxType == TaxType.Monthly && r.DayOfMonth.HasValue && r.DayOfMonth.Value == date.Day) return 1;
                    if (r.TaxType == TaxType.Weekly && r.DayOfWeek.HasValue && r.DayOfWeek.Value == date.DayOfWeek) return 1;
                    return 0; // No specific day match for this rule or type doesn't have such specificity
                })
                .FirstOrDefault();

            // --- Refined Logic to handle "Specific Day" rules that don't match the current date's day ---
            // The `OrderBy` above will pick the highest precedence *TaxType*.
            // However, a rule like "Daily on DayOfYear 100" should *not* apply on DayOfYear 200,
            // even if "Daily" is the highest type precedence. These `if` blocks ensure that
            // if the selected "most specific" rule *requires* a specific day match (DayOfMonth/DayOfWeek/DayOfYear)
            // and that match fails, we re-evaluate and find the next best rule.

            // If the initially chosen rule is Daily and it specifies a DayOfYear, but that DayOfYear doesn't match the current date
            if (mostSpecificRule?.TaxType == TaxType.Daily && mostSpecificRule.DayOfYear.HasValue && mostSpecificRule.DayOfYear.Value != date.DayOfYear)
            {
                // Exclude this specific daily rule and find the next most specific rule from the rest
                mostSpecificRule = applicableRules
                    .Where(r => r.Id != mostSpecificRule.Id) // Exclude the rule that failed its specific day match
                    .OrderByDescending(r => GetTaxTypePrecedence(r.TaxType))
                    .ThenByDescending(r =>
                    {
                        if (r.TaxType == TaxType.Monthly && r.DayOfMonth.HasValue && r.DayOfMonth.Value == date.Day) return 1;
                        if (r.TaxType == TaxType.Weekly && r.DayOfWeek.HasValue && r.DayOfWeek.Value == date.DayOfWeek) return 1;
                        return 0;
                    })
                    .FirstOrDefault();
            }

            // If the (potentially re-evaluated) chosen rule is Monthly and it specifies a DayOfMonth, but that DayOfMonth doesn't match the current date
            if (mostSpecificRule?.TaxType == TaxType.Monthly && mostSpecificRule.DayOfMonth.HasValue && mostSpecificRule.DayOfMonth.Value != date.Day)
            {
                // Exclude this specific monthly rule and find the next most specific rule
                mostSpecificRule = applicableRules
                    .Where(r => r.Id != mostSpecificRule.Id)
                    .OrderByDescending(r => GetTaxTypePrecedence(r.TaxType))
                    .ThenByDescending(r =>
                    {
                        if (r.TaxType == TaxType.Weekly && r.DayOfWeek.HasValue && r.DayOfWeek.Value == date.DayOfWeek) return 1;
                        return 0;
                    })
                    .FirstOrDefault();
            }

            // If the (potentially re-evaluated) chosen rule is Weekly and it specifies a DayOfWeek, but that DayOfWeek doesn't match the current date
            if (mostSpecificRule?.TaxType == TaxType.Weekly && mostSpecificRule.DayOfWeek.HasValue && mostSpecificRule.DayOfWeek.Value != date.DayOfWeek)
            {
                // Exclude this specific weekly rule and find the next most specific rule (which would likely be Yearly)
                mostSpecificRule = applicableRules
                    .Where(r => r.Id != mostSpecificRule.Id)
                    .OrderByDescending(r => GetTaxTypePrecedence(r.TaxType))
                    .FirstOrDefault(); // No further specificity checks needed here, as Yearly has no specific day props
            }

            return mostSpecificRule?.Value ?? 0.0m;
        }
